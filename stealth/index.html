<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Stealth Roulette Tracker • v1.6 • Build: 2026-01-06 • CASH PRIORITY</title>
<style>
:root{color-scheme:dark;--bg:#070b14;--panel:#0b1220;--bubbleIn:#121b2f;--bubbleOut:#17325e;--txt:#e5e7eb;--muted:#94a3b8;--border:rgba(255,255,255,.10);--pill:rgba(255,255,255,.08)}
*{box-sizing:border-box}
body{margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:radial-gradient(1400px 800px at 30% 0%, #0b1832, var(--bg));color:var(--txt)}
.header{padding:16px 14px 10px 14px;border-bottom:1px solid var(--border);background:linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,0))}
.h1{font-size:26px;font-weight:800;letter-spacing:.2px}
.h2{margin-top:4px;color:var(--muted);font-size:13px;line-height:1.25}
.wrap{max-width:820px;margin:0 auto;min-height:100vh;display:flex;flex-direction:column}
.chat{flex:1; padding:14px; display:flex; flex-direction:column; gap:10px; overflow:auto}
.bubble{max-width:92%; padding:12px 12px; border-radius:18px; border:1px solid var(--border); box-shadow:0 12px 32px rgba(0,0,0,.25)}
.in{align-self:flex-start; background:rgba(18,27,47,.85)}
.out{align-self:flex-end; background:rgba(23,50,94,.72); border-color:rgba(96,165,250,.25)}
.meta{display:flex; gap:8px; flex-wrap:wrap; margin-bottom:6px}
.pill{display:inline-flex; align-items:center; gap:6px; padding:2px 9px; border-radius:999px; background:var(--pill); border:1px solid rgba(255,255,255,.10); font-size:12px; color:var(--muted)}
pre{margin:0; white-space:pre-wrap; word-break:break-word; font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace; font-size:12px; line-height:1.35}
.footer{padding:12px 12px calc(12px + env(safe-area-inset-bottom)); border-top:1px solid var(--border); background:linear-gradient(180deg, rgba(0,0,0,0), rgba(0,0,0,.35))}
form{display:flex; gap:10px; align-items:center}
input[type="text"]{flex:1; padding:14px 14px; border-radius:16px; border:1px solid rgba(255,255,255,.14); background:rgba(7,11,20,.55); color:var(--txt); outline:none}
button{padding:14px 16px; border-radius:16px; border:1px solid rgba(255,255,255,.14); background:rgba(255,255,255,.08); color:var(--txt); font-weight:800; cursor:pointer}
button:active{transform:translateY(1px)}
.smallhint{color:var(--muted); font-size:12px; margin-top:10px; line-height:1.35}
a{color:#9ec5ff}
</style>
</head>
<body>
<div class="wrap">
  <div class="header">
    <div class="h1">Scott</div>
    <div class="h2">Texting view • STEALTH TEXT MODE — v1.4 (rewrite send-stable) • Build 2026-01-05</div>
  </div>

  <div id="chat" class="chat" aria-live="polite"></div>

  <div class="footer">
    <form id="composer" action="javascript:void(0);">
      <input id="msg" type="text" autocomplete="off" autocapitalize="none" spellcheck="false"
             placeholder="Type a spin, comma list, or command…"/>
      <button id="send" type="submit">Send</button>
    </form>
    <div class="smallhint">
      First: paste history as comma-separated numbers (example: <b>0,00,34,23,5,17</b>) then Send.<br/>
      Commands: <b>status</b>, <b>trend</b>, <b>explain</b>, <b>explain 2</b>, <b>wheel</b>, <b>export</b>, <b>offline</b>, <b>clear</b>, <b>help</b>.<br/>
      Set casino: <b>casino Caesars</b>
    </div>
  </div>
</div>

<script>
(() => {
  "use strict";

  // ---------- Safety: surface errors in chat ----------
  const ERRKEY = "stealth_last_error_v1_4";
  window.addEventListener("error", (e) => {
    try { localStorage.setItem(ERRKEY, String(e.message || e.error || e)); } catch(_) {}
  });

  const STORAGE_KEY = "roulette_stealth_textmode_v1_4";
  const RED = new Set([1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36]);
  const BLACK = new Set([2,4,6,8,10,11,13,15,17,20,22,24,26,28,29,31,33,35]);

  // Junko quadrants
  const GN = new Set(["00",0,1,2,9,10,13,14,27,28]);
  const HO = new Set([24,25,26,29,30,33,34,35,36]);
  const LO = new Set([3,4,8,11,12,15,16,22,23]);
  const MID= new Set([5,6,7,17,18,19,20,21,31,32]);

  // Opposite Segment strategy sets (00 represented as "00"; 0 is 0)
  const SEG_A = new Set([13,1,"00",27,10,9,28,0,2,14]);
  const SEG_B = new Set([31,18,6,21,33,17,5,22,32,20]);
  const SEG_C = new Set([25,29,12,8,19,26,30,11,7]);
  const SEG_D = new Set([36,24,3,15,34,35,23,4,16]);
  const SEG_ORDER = ["A","B","C","D"];

  function oppositeSeg(name){
    if(name==="A") return "C";
    if(name==="B") return "D";
    if(name==="C") return "A";
    return "B";
  }
  function segSet(name){
    if(name==="A") return SEG_A;
    if(name==="B") return SEG_B;
    if(name==="C") return SEG_C;
    return SEG_D;
  }

  const state = {
    spins: [], // newest-first, each entry: {n, t}
    casino: "",
    lastTop: [], // {name,score,tag,howto,numbers}
    lastTrend: ""
  };

  const $ = (id) => document.getElementById(id);

  function nowISO(){
    const d = new Date();
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth()+1).padStart(2,"0");
    const dd = String(d.getDate()).padStart(2,"0");
    return `${yyyy}-${mm}-${dd}`;
  }

  function pushBubble(text, kind="in", metaPills=[]){
    const chat = $("chat");
    const wrap = document.createElement("div");
    wrap.className = "bubble " + (kind==="out" ? "out" : "in");
    if(metaPills && metaPills.length){
      const meta = document.createElement("div");
      meta.className = "meta";
      metaPills.forEach(p => {
        const s = document.createElement("span");
        s.className="pill";
        s.textContent = p;
        meta.appendChild(s);
      });
      wrap.appendChild(meta);
    }
    const pre = document.createElement("pre");
    pre.innerHTML = text; // we will only inject safe text we generate (no user html)
    wrap.appendChild(pre);
    chat.appendChild(wrap);
    // scroll
    requestAnimationFrame(()=>{ chat.scrollTop = chat.scrollHeight; });
  }

  function escapeHTML(s){
    return String(s).replace(/[&<>"]/g, (c)=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;" }[c]));
  }

  function save(){
    try{
      localStorage.setItem(STORAGE_KEY, JSON.stringify({
        spins: state.spins,
        casino: state.casino
      }));
    }catch(_){}
  }
  function load(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return;
      const obj = JSON.parse(raw);
      if(Array.isArray(obj.spins)) state.spins = obj.spins.filter(x=>x && (x.n===0 || x.n==="00" || (Number.isFinite(Number(x.n)) && Number(x.n)>=1 && Number(x.n)<=36)))
                                                  .map(x=>({n:(x.n==="00"?"00":Number(x.n)), t:Number(x.t)||Date.now()}));
      if(typeof obj.casino==="string") state.casino = obj.casino;
    }catch(_){}
  }

  function parseToken(tok){
    const t = String(tok||"").trim();
    if(!t) return null;
    if(t==="00") return "00";
    if(t==="0") return 0;
    const n = Number(t);
    if(!Number.isFinite(n)) return null;
    if(n===0) return 0;
    if(n>=1 && n<=36) return n;
    return null;
  }

  function parseCommaList(s){
    const parts = String(s||"").split(/[,\s]+/).filter(Boolean);
    const out = [];
    for(const p of parts){
      const v = parseToken(p);
      if(v===null) continue;
      out.push(v);
    }
    return out;
  }

  function windowVals(n=15){
    return state.spins.slice(0,n).map(x=>x.n);
  }
  function isGreen(n){ return n===0 || n==="00"; }
  function colOf(n){
    if(isGreen(n)) return null;
    const v=Number(n);
    const r=v%3;
    return r===1?1:(r===2?2:3);
  }
  function dozenOf(n){
    if(isGreen(n)) return null;
    const v=Number(n);
    return v<=12?1:(v<=24?2:3);
  }
  function streetId(n){
    if(isGreen(n)) return null;
    const v=Number(n);
    return Math.floor((v-1)/3)+1; //1..12
  }
  function cornerOf(n){
    // return one of the fixed 6 diamonds corners index if in them (1..6) else null
    if(isGreen(n)) return null;
    const v=Number(n);
    const corners = [
      new Set([1,2,4,5]),
      new Set([7,8,10,11]),
      new Set([13,14,16,17]),
      new Set([19,20,22,23]),
      new Set([25,26,28,29]),
      new Set([31,32,34,35])
    ];
    for(let i=0;i<corners.length;i++){
      if(corners[i].has(v)) return i+1;
    }
    return null;
  }

  function junkoBucket(n){
    const k = (n==="00") ? "00" : Number(n);
    if(GN.has(k)) return "GN";
    if(HO.has(k)) return "HO";
    if(LO.has(k)) return "LO";
    if(MID.has(k)) return "M";
    return null;
  }

  function dsKey(n){
    // double street index per dozen: 1..3
    if(isGreen(n)) return null;
    const v = Number(n);
    const d = v<=12?1:(v<=24?2:3);
    const base = (d-1)*12;
    const a = base+1, b = base+4, c = base+7;
    let i = 2;
    if(v>=a && v<=a+5) i=1;
    else if(v>=b && v<=b+5) i=2;
    else if(v>=c && v<=c+5) i=3;
    return {d,i};
  }

  function counts(vals){
    const c = {c1:0,c2:0,c3:0,d1:0,d2:0,d3:0,red:0,black:0,high:0,low:0,even:0,odd:0,gn:0,ho:0,lo:0,m:0,green:0};
    for(const n of vals){
      if(isGreen(n)) c.green++;
      const col=colOf(n); if(col===1)c.c1++; if(col===2)c.c2++; if(col===3)c.c3++;
      const dz=dozenOf(n); if(dz===1)c.d1++; if(dz===2)c.d2++; if(dz===3)c.d3++;
      if(!isGreen(n)){
        if(RED.has(Number(n))) c.red++; else c.black++;
        if(Number(n)>=19) c.high++; else c.low++;
        if(Number(n)%2===0) c.even++; else c.odd++;
      }
      const jb=junkoBucket(n);
      if(jb==="GN") c.gn++; if(jb==="HO") c.ho++; if(jb==="LO") c.lo++; if(jb==="M") c.m++;
    }
    return c;
  }

  function repeatInfo(vals, lookback){
    const newest = vals[0];
    if(vals.length<2) return {num:false, street:false, corner:false, ds:false, text:[]};
    let num=false, street=false, corner=false, ds=false;
    const t=[];
    for(let i=1;i<Math.min(vals.length, lookback+1); i++){
      if(vals[i]===newest){ num=true; t.push(`Number repeat: ${newest} within ${i} spin(s)`); break; }
    }
    const s0=streetId(newest);
    if(s0){
      for(let i=1;i<Math.min(vals.length, lookback+1); i++){
        const si=streetId(vals[i]);
        if(si && si===s0){ street=true; t.push(`Street repeat: S${s0} within ${i} spin(s)`); break; }
      }
    }
    const c0=cornerOf(newest);
    if(c0){
      for(let i=1;i<Math.min(vals.length, lookback+1); i++){
        const ci=cornerOf(vals[i]);
        if(ci && ci===c0){ corner=true; t.push(`Corner repeat: C${c0} within ${i} spin(s)`); break; }
      }
    }
    const d0=dsKey(newest);
    if(d0){
      for(let i=1;i<Math.min(vals.length, lookback+1); i++){
        const di=dsKey(vals[i]);
        if(di && di.d===d0.d && di.i===d0.i){ ds=true; t.push(`Double-street repeat: D${d0.d}-${d0.i} within ${i} spin(s)`); break; }
      }
    }
    return {num,street,corner,ds,text:t};
  }

  function tableState(vals){
    if(vals.length<10) return "Warming up";
    const cts = counts(vals.slice(0,15));
    const rep = repeatInfo(vals, 5);
    if(rep.num || rep.street || rep.corner || rep.ds) return "Repeat-heavy";
    const colMax = Math.max(cts.c1,cts.c2,cts.c3);
    const dozMax = Math.max(cts.d1,cts.d2,cts.d3);
    const qMax = Math.max(cts.gn,cts.ho,cts.lo,cts.m);
    if(colMax>=7 || dozMax>=7 || qMax>=6) return "Concentrated";
    return "Flat / choppy";
  }

  // ---------- Strategy models ----------
  function strat6Diamonds(){
    const corners = [
      [1,2,4,5],
      [7,8,10,11],
      [13,14,16,17],
      [19,20,22,23],
      [25,26,28,29],
      [31,32,34,35]
    ];
    const flatNums = corners.flat();
    const howto =
`6 Diamonds + 0/00 (COMP)
Bet these 6 corners (1 unit each corner):
- 1/2/4/5
- 7/8/10/11
- 13/14/16/17
- 19/20/22/23
- 25/26/28/29
- 31/32/34/35
Optional: add 0 and 00 as 1 unit each (table dependent).
Progression: +1 unit to all corners after a loss; -1 after a win (min 1).
Exit: stop on recovery or if you hit stop-loss rules.`;
    return {name:"COMP — 6 Diamonds + 0/00", tag:"COMP", score:0, numbers:[...flatNums,0,"00"], howto};
  }

  
  function stratMoonDance(vals){
    // Needs 15 prior spins; compute 2 least-hit streets per dozen (4 streets per dozen).
    if(vals.length < 15) return null;
    const last15 = vals.slice(0,15);
    // street id 1..12
    const c = {d1:[0,0,0,0], d2:[0,0,0,0], d3:[0,0,0,0]};
    last15.forEach(n=>{
      if(n===0 || n==="00") return;
      const v = Number(n);
      if(!(v>=1 && v<=36)) return;
      const s = Math.floor((v-1)/3)+1; // 1..12
      const dozen = (s<=4)?1:((s<=8)?2:3);
      const within = ((s-1)%4)+1; // 1..4
      const arr = dozen===1?c.d1:(dozen===2?c.d2:c.d3);
      arr[within-1] += 1;
    });
    function pick2(arr){
      const items = arr.map((hits,i)=>({hits, idx:i+1}));
      items.sort((a,b)=>(a.hits-b.hits)||(a.idx-b.idx));
      return [items[0].idx, items[1].idx];
    }
    const p1 = pick2(c.d1), p2 = pick2(c.d2), p3 = pick2(c.d3);
    function numsFor(dozen, within){
      const base = (dozen-1)*12;
      const start = base + (within-1)*3 + 1;
      return [start,start+1,start+2];
    }
    const nums = [];
    p1.forEach(w=>nums.push(...numsFor(1,w)));
    p2.forEach(w=>nums.push(...numsFor(2,w)));
    p3.forEach(w=>nums.push(...numsFor(3,w)));
    const uniq = Array.from(new Set(nums)).sort((a,b)=>a-b);

    // scoring: more depleted streets => higher
    const lows = [c.d1[p1[0]-1],c.d1[p1[1]-1],c.d2[p2[0]-1],c.d2[p2[1]-1],c.d3[p3[0]-1],c.d3[p3[1]-1]];
    const zeros = lows.filter(x=>x===0).length;
    const avg = lows.reduce((a,b)=>a+b,0)/lows.length;
    let score = 78 + zeros*5 + Math.max(0,(2-avg))*8; // heuristic
    score = Math.max(0, Math.min(99, Math.round(score)));

    return {
      name: "CASH — Moon Dance 2S/Dozen (Junko Base)",
      score,
      why: `Least-hit streets per dozen (18 numbers).`,
      howto:
`MOON DANCE 2S/DOZEN — JUNKO BASE (CASH)

Numbers to bet (18)
${uniq.join(", ")}

Entry
- Wait until you have 15 prior spins logged.

Bet / Progression
- Bet $b on EACH of the 18 numbers (straight-up).
- Start b=1.
- If spin hits any of the 18 OR hits 0/00: treat as WIN → reset b=1 and recompute streets next cycle.
- If spin misses all 18 AND misses 0/00: double b.

0/00 bailout hedge (only when b>=8)
- Add $2 on 0 and $2 on 00.

Exits / Guardrail
- Cashout +$100 (after spin)
- Stop-loss -$200
- Do NOT place a bet if worst-case loss would breach -$200.`,
      tag:"CASH",
      numbers: uniq
    };
  }

  function stratTrinityJunkoV2(vals){
    if(vals.length < 15) return null;
    const last15 = vals.slice(0,15);
    const dsCold = last15.filter(n=> (n!==0 && n!=="00" && Number(n)>=1 && Number(n)<=12)).length; // DS 1-12 proxy
    const corners = [13,17,14,18,19,23,20,24,25,29,26,30,31,35,32,36];
    const cornerHits = last15.filter(n=> n!=="00" && n!==0 && corners.includes(Number(n))).length;
    let score = 74 + Math.max(0, cornerHits-6)*2 + Math.max(0, 4-dsCold)*3;
    score = Math.max(0, Math.min(98, Math.round(score)));

    return {
      name: "CASH — Trinity–Junko v2",
      score,
      why: "Corner + DS cadence.",
      howto:
`TRINITY–JUNKO v2 (CASH)

Double Streets
- Bet DS 1–6 and 7–12 (two 6-lines).

Corners (8)
- 13/17, 14/18, 19/23, 20/24, 25/29, 26/30, 31/35, 32/36
Numbers (corner coverage)
13,14,17,18,19,20,23,24,25,26,29,30,31,32,35,36

Units
- ds_unit starts 1; +1 each spin with NO DS hit; cap 5.
- If ANY DS hits (1–12), remove BOTH DS until next reset; set ds_unit=1.
- corner_unit doubles every 3 spins (win or loss); cap $16.
- Remove any corner(s) that hit (multiple can be removed).

Resets
- Reset DS + corners + units when session P/L crosses +$15 milestones (15,30,45,60,75,90) OR when ≤2 corners remain.

Exits / Guardrail
- Cashout +$90 (after spin)
- Stop-loss -$200
- Do NOT place a bet if worst-case loss would breach -$200.`,
      tag:"CASH",
      numbers: corners
    };
  }

  function stratCornersDSFollowLeader(vals){
    if(vals.length < 3) return null;
    // map number to DS label
    function dsLabel(n){
      if(n===0 || n==="00") return null;
      const v = Number(n);
      if(!(v>=1 && v<=36)) return null;
      const street = Math.floor((v-1)/3)+1; //1..12
      const startStreet = (street%2===1)?street:(street-1);
      const a = (startStreet-1)*3 + 1;
      const b = a+5;
      return `${a}-${b}`;
    }
    const dsAll = ["1-6","7-12","13-18","19-24","25-30","31-36"];
    const d0 = dsLabel(vals[0]);
    const d1 = dsLabel(vals[1]);
    if(!d0) return null;

    function pickBlock(dMost, dOther){
      const iMost = dsAll.indexOf(dMost);
      if(iMost<0) return dsAll.slice(0,4);
      if(dOther && dsAll.indexOf(dOther)>=0){
        const i2 = dsAll.indexOf(dOther);
        const lo = Math.min(iMost,i2), hi = Math.max(iMost,i2);
        if(hi-lo <= 3){
          let s = Math.max(0, hi-3);
          s = Math.min(s, lo);
          s = Math.min(s, dsAll.length-4);
          return dsAll.slice(s,s+4);
        }
      }
      const s = Math.max(0, Math.min(dsAll.length-4, iMost-1));
      return dsAll.slice(s,s+4);
    }

    const block = pickBlock(d0, d1);
    const cornerMap = {
      "1-6":[2,3,5,6],
      "7-12":[8,9,11,12],
      "13-18":[14,15,17,18],
      "19-24":[20,21,23,24],
      "25-30":[26,27,29,30],
      "31-36":[32,33,35,36]
    };
    const nums = [];
    block.forEach(lbl=>{
      const [a,b]=lbl.split("-").map(Number);
      for(let x=a;x<=b;x++) nums.push(x);
      nums.push(...(cornerMap[lbl]||[]));
    });
    const uniq = Array.from(new Set(nums)).sort((a,b)=>a-b);

    // score heuristic: more recent hits inside block
    const last15 = vals.slice(0,15);
    const inBlock = (n)=>{
      if(n===0||n==="00") return false;
      const v=Number(n);
      return block.some(lbl=>{
        const [a,b]=lbl.split("-").map(Number);
        return v>=a && v<=b;
      });
    };
    const hit6 = last15.slice(0,6).filter(inBlock).length;
    const hit15 = last15.filter(inBlock).length;
    let score = 70 + hit6*4 + Math.max(0, hit15-6)*2;
    score = Math.max(0, Math.min(97, Math.round(score)));

    return {
      name: "CASH — Corners + DS (Follow the Leader)",
      score,
      why: `DS block: ${block.join(", ")} (locked until loss).`,
      howto:
`CORNERS + DOUBLE STREETS — FOLLOW THE LEADER (CASH/GRIND)

Selected DS block (4 adjacent, locked until loss)
${block.join(", ")}

Numbers (DS + paired corners)
${uniq.join(", ")}

Base (Level 1)
- Double Streets: 4 adjacent non-overlapping DS × $3 each
- Corners: paired corners × $1 each

Lock rule
- Do NOT change DS after wins.
- Recalculate DS ONLY after a losing spin.

Progression
- Multiplier m starts 1.
- Increase m by +1 after every 2 consecutive losses.
- Ladder down m by −1 after any win (min m=1).
- Bet sizes at level m:
  - DS bet = $3 × m
  - Corner bet = $1 × m

Reset / Exits
- Reset to Level 1 when session profit ≥ $30.
- Cashout +$50; Stop loss −$300.`,
      tag:"CASH",
      numbers: uniq
    };
  }

  function stratSlowSteady(vals){
    if(vals.length < 15) return null;
    const last15 = vals.slice(0,15);
    const c15 = counts(last15);
    const dozMax = Math.max(c15.d1,c15.d2,c15.d3);
    const colMax = Math.max(c15.c1,c15.c2,c15.c3);
    let score = 55 + Math.max(dozMax,colMax)*4;
    score = Math.max(0, Math.min(90, Math.round(score)));
    return {
      name: "CASH — Slow & Steady (situational)",
      score,
      why: `Bias: Dozen max ${dozMax}/15, Column max ${colMax}/15.`,
      howto:
`SLOW & STEADY (SITUATIONAL)

Use when you see structural bias (dozens/columns leaning) but no clear repeat signal.

How to play (generic)
- Identify the strongest structural lane (dozen or column) in the last-15.
- Flat bet with tight session limits; avoid over-progression.
- Exit if the bias normalizes.

Note
- This tracker treats this as a situational option, not a primary cash driver.`,
      tag:"CASH",
      numbers:[]
    };
  }

function stratJunkoHot(vals){
    const w15 = vals.slice(0,15);
    const cts = counts(w15);
    const q = [
      {k:"GN", n:cts.gn, nums:[..."00,0,1,2,9,10,13,14,27,28".split(",").map(x=>x==="00"?"00":Number(x))]},
      {k:"HO", n:cts.ho, nums:[24,25,26,29,30,33,34,35,36]},
      {k:"LO", n:cts.lo, nums:[3,4,8,11,12,15,16,22,23]},
      {k:"M",  n:cts.m,  nums:[5,6,7,17,18,19,20,21,31,32]},
    ];
    q.sort((a,b)=>b.n-a.n);
    const top=q[0];
    const howto =
`Junko Hot (Quadrant Momentum) (CASH)
Bet the hottest quadrant (flat only):
- ${top.k} numbers: ${top.nums.map(x=>String(x)).join(", ")}
Units: 1 unit each number (5–10 numbers typical; start with the full list if unsure).
Re-check every spin on last-15. Exit if the hottest drops below the trigger.`;
    return {name:"CASH — Junko Hot (Quadrant Momentum)", tag:"CASH", score:0, numbers:top.nums, howto, extra:`${top.k} max=${top.n}/15`};
  }

  function stratOppositeSegment(vals){
    const w15 = vals.slice(0,15);
    const c = {A:0,B:0,C:0,D:0};
    for(const n of w15){
      const k = (n==="00") ? "00" : Number(n);
      if(SEG_A.has(k)) c.A++;
      if(SEG_B.has(k)) c.B++;
      if(SEG_C.has(k)) c.C++;
      if(SEG_D.has(k)) c.D++;
    }
    // tie-break A→B→C→D
    let hottest="A";
    for(const k of SEG_ORDER){
      if(c[k] > c[hottest]) hottest=k;
    }
    const opp = oppositeSeg(hottest);
    const oppNums = Array.from(segSet(opp)).map(x=>x);
    const howto =
`Opposite-Segment Contrarian (Option 1) (CASH)
Trigger: in last 15, a segment hits ≥ 6 (A→B→C→D tie-break).
Then bet the OPPOSITE segment until first win.

Current hottest: ${hottest} (${c[hottest]}/15) → bet ${opp}:
Numbers: ${oppNums.map(x=>String(x)).join(", ")}

Units: $1 per number.
Escalation: +1 unit after 3 consecutive losing bet-spins.
Session risk: cash out at +$100, stop loss at -$200.
Guardrail: do not place any bet that could breach -$200 on a loss.`;
    return {name:"CASH — Opposite Segment Contrarian", tag:"CASH", score:0, numbers:oppNums, howto, extra:`Hot ${hottest}=${c[hottest]}/15`};
  }

  function scoreAll(vals){
  const plays = [];

  // Existing baseline strategies
  const s1 = stratComp6Diamonds(vals); if(s1) plays.push(s1);
  const s2 = stratOppositeSegment(vals); if(s2) plays.push(s2);
  const s3 = stratJunkoHot(vals); if(s3) plays.push(s3);
  const s4 = stratDSCashPower(vals); if(s4) plays.push(s4);

  // New CASH strategies
  const md = stratMoonDance(vals); if(md) plays.push(md);
  const tj = stratTrinityJunkoV2(vals); if(tj) plays.push(tj);
  const ftl = stratCornersDSFollowLeader(vals); if(ftl) plays.push(ftl);
  const ss = stratSlowSteady(vals); if(ss) plays.push(ss);

  // Priority order when multiple strategies score >=85 (CASH only)
  const PRIORITY = [
    "CASH — Moon Dance 2S/Dozen (Junko Base)",
    "CASH — Trinity–Junko v2",
    "CASH — Opposite-Segment Contrarian (Option 1)",
    "CASH — Corners + DS (Follow the Leader)",
    "CASH — Junko Hot / Slow & Steady",
    "CASH — Slow & Steady (situational)"
  ];

  plays.sort((a,b)=>{
    // If both are CASH and both >=85, use priority order first
    const aCash = (a.tag==="CASH" && a.score>=85);
    const bCash = (b.tag==="CASH" && b.score>=85);
    if(aCash && bCash){
      const ia = PRIORITY.indexOf(a.name);
      const ib = PRIORITY.indexOf(b.name);
      if(ia!==-1 && ib!==-1 && ia!==ib) return ia-ib;
    }
    // otherwise by score desc
    if(b.score !== a.score) return b.score - a.score;
    // stable name
    return String(a.name).localeCompare(String(b.name));
  });

  return plays.slice(0,3);
}


  function trendText(){
    const vals = windowVals(15);
    const cts = counts(vals);
    const rep = repeatInfo(vals, 10);
    const st = tableState(vals);
    const cols = `${cts.c1}/${cts.c2}/${cts.c3}`;
    const doz = `${cts.d1}/${cts.d2}/${cts.d3}`;
    // DS summary (per dozen)
    const ds = {d1:[0,0,0], d2:[0,0,0], d3:[0,0,0]};
    for(const n of vals){
      const k=dsKey(n);
      if(!k) continue;
      const arr = k.d===1?ds.d1:(k.d===2?ds.d2:ds.d3);
      arr[k.i-1]+=1;
    }
    const dsLine = `D1 ${ds.d1.join("/")} | D2 ${ds.d2.join("/")} | D3 ${ds.d3.join("/")}`;
    const last20 = state.spins.slice(0,20).map(x=>String(x.n)).join(", ");
    const bullets = rep.text.length ? rep.text.map(x=>`• ${x}`).join("\n") : "• No repeat flags in lookback.";
    return (
`Trend snapshot (last 15)  [${st}]
Columns: ${cols}
Dozens:  ${doz}
Double streets: ${dsLine}
Red/Black: ${cts.red}/${cts.black}
High/Low:  ${cts.high}/${cts.low}
Even/Odd:  ${cts.even}/${cts.odd}
Junko: GN ${cts.gn} | HO ${cts.ho} | LO ${cts.lo} | M ${cts.m}

Repeat flags
${bullets}

Last 20: ${last20}`
    );
  }

  function statusText(){
    const vals = windowVals(15);
    const scored = scoreAll(vals);
    state.lastTop = scored.plays;
    const lines = scored.plays.map((p,i)=> `${i+1}. ${p.name}  (${p.tag} • ${p.score})`).join("\n");
    return `Top strategies (name + score)\n${lines}`;
  }

  function wheelText(){
    const lastN = state.spins.slice(0,20).map(x=>x.n);
    const counts = {};
    for(const n of lastN){
      const k = String(n);
      counts[k] = (counts[k]||0)+1;
    }
    // order by American wheel order
    const WHEEL = [0,28,9,26,30,11,7,20,32,17,5,22,34,15,3,24,36,13,1,"00",27,10,25,29,12,8,19,31,18,6,21,33,16,4,23,35,14,2];
    let out = "Wheel histogram (last 20)\n";
    const max = Math.max(1, ...Object.values(counts));
    for(const n of WHEEL){
      const k = String(n);
      const c = counts[k]||0;
      const bars = "█".repeat(Math.round((c/max)*12));
      out += `${k.padStart(2," ")}: ${String(c).padStart(2," ")} ${bars}\n`;
    }
    return out.trim();
  }

  function csv(){
    const lines = ["number,casino,date,time"];
    const casino = (state.casino||"").replace(/"/g,'""');
    const arr = state.spins.slice().reverse();
    for(const x of arr){
      const d = new Date(x.t);
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth()+1).padStart(2,"0");
      const dd = String(d.getDate()).padStart(2,"0");
      const hh = String(d.getHours()).padStart(2,"0");
      const mi = String(d.getMinutes()).padStart(2,"0");
      const ss = String(d.getSeconds()).padStart(2,"0");
      lines.push(`${x.n},"${casino}",${yyyy}-${mm}-${dd},${hh}:${mi}:${ss}`);
    }
    return lines.join("\n");
  }

  function helpText(){
    return (
`Help — commands
status      → top strategies (name + score)
trend       → compact stats + repeats + last20 list
explain     → how to play + numbers for #1 strategy
explain 2   → how to play + numbers for #2 strategy
wheel       → wheel-order histogram for last 20
export      → shows CSV (copy manually)
offline     → offline reminders & backup tips
clear       → wipe local history

Input formats
- Single spin: 17
- Comma list: 17,0,00,34
- First load: paste a long history list, then send.

Casino
- After first history, set casino with: casino <name>
  example: casino Caesars Joliet`
    );
  }

  function offlineText(){
    return (
`Offline reminders (cruise/airplane mode)
• This page runs fully offline once loaded (no server calls).
• Spins + casino name are saved on-device (localStorage).
• Export: text "export" to display CSV; copy it somewhere safe (Notes/email to yourself later).
• If you clear Safari/Chrome website data, localStorage can be wiped—export before doing that.
• If you open the same URL in a different browser/device, it will not have your local data (export/import is your bridge).`
    );
  }

  function explainNth(n){
    if(!state.lastTop || state.lastTop.length<1){
      // force compute
      statusText();
    }
    const p = state.lastTop[n-1];
    if(!p) return "No strategy available yet. Add more spins, then text: status";
    return p.howto;
  }

  // ---------- Input handling ----------
  function addSpins(list){
    const t = Date.now();
    for(const n of list){
      state.spins.unshift({n:n, t:t});
    }
    if(state.spins.length>8000) state.spins = state.spins.slice(0,8000);
    save();
  }

  function handleUser(text){
    const raw = String(text||"").trim();
    if(!raw) return;

    pushBubble(escapeHTML(raw), "out");

    const lower = raw.toLowerCase();

    // casino
    if(lower.startsWith("casino ")){
      state.casino = raw.slice(7).trim();
      save();
      pushBubble(`Casino set: <b>${escapeHTML(state.casino||"")}</b>`, "in", ["saved"]);
      return;
    }

    // commands
    if(lower==="help"){
      pushBubble(escapeHTML(helpText()), "in", ["help"]);
      return;
    }
    if(lower==="offline"){
      pushBubble(escapeHTML(offlineText()), "in", ["offline"]);
      return;
    }
    if(lower==="clear"){
      state.spins = [];
      state.casino = "";
      save();
      pushBubble("Cleared. Paste history to start again.", "in", ["cleared"]);
      return;
    }
    if(lower==="status"){
      if(state.spins.length<10){
        pushBubble("Need at least ~10 spins. Paste history as comma list first.", "in", ["status"]);
        return;
      }
      pushBubble(escapeHTML(statusText()), "in", ["status"]);
      return;
    }
    if(lower==="trend"){
      if(state.spins.length<10){
        pushBubble("Need at least ~10 spins. Paste history first.", "in", ["trend"]);
        return;
      }
      pushBubble(escapeHTML(trendText()), "in", ["trend"]);
      return;
    }
    if(lower==="wheel"){
      if(state.spins.length<1){
        pushBubble("No spins yet.", "in", ["wheel"]);
        return;
      }
      pushBubble(escapeHTML(wheelText()), "in", ["wheel"]);
      return;
    }
    if(lower==="export"){
      if(state.spins.length<1){
        pushBubble("No spins to export.", "in", ["export"]);
        return;
      }
      pushBubble(escapeHTML(csv()), "in", ["export CSV"]);
      return;
    }
    if(lower==="explain"){
      if(state.spins.length<10){
        pushBubble("Need some spins first. Paste history, then text: status", "in", ["explain"]);
        return;
      }
      pushBubble(escapeHTML(explainNth(1)), "in", ["explain #1"]);
      return;
    }
    if(lower==="explain 2"){
      if(state.spins.length<10){
        pushBubble("Need some spins first. Paste history, then text: status", "in", ["explain 2"]);
        return;
      }
      pushBubble(escapeHTML(explainNth(2)), "in", ["explain #2"]);
      return;
    }

    // numbers (single or list)
    const list = parseCommaList(raw);
    if(list.length){
      const isFirstLoad = state.spins.length===0 && list.length>=10;
      addSpins(list);
      if(isFirstLoad && !state.casino){
        pushBubble("History saved. What casino are you at? Reply: casino <name>", "in", ["casino?"]);
      } else {
        // after any numbers, show compact status automatically
        if(state.spins.length>=10){
          pushBubble(escapeHTML(statusText()), "in", ["status"]);
        } else {
          pushBubble(`Saved ${list.length} spin(s).`, "in", ["saved"]);
        }
      }
      return;
    }

    pushBubble("Unrecognized. Send a number (17) or comma list (0,00,34,23) or text: help", "in", ["unrecognized"]);
  }

  function boot(){
    load();

    // welcome
    pushBubble("Ready. Paste history as comma-separated numbers, then Send.", "in", ["ready"]);

    // show last error (if any) — helpful for debugging white screen
    try{
      const lastErr = localStorage.getItem(ERRKEY);
      if(lastErr){
        pushBubble("Last load error detected (cleared now):\n" + escapeHTML(lastErr), "in", ["debug"]);
        localStorage.removeItem(ERRKEY);
      }
    }catch(_){}

    // wire events (multiple paths to ensure iOS reliability)
    const form = $("composer");
    const input = $("msg");
    const send = $("send");

    const submit = (e)=>{
      if(e) { e.preventDefault(); e.stopPropagation(); }
      const txt = input.value;
      input.value = "";
      handleUser(txt);
      input.focus();
      return false;
    };

    // Submit paths
    form.addEventListener("submit", submit, {passive:false});
    send.addEventListener("click", submit, {passive:false});
    send.addEventListener("touchend", (e)=>{ e.preventDefault(); submit(e); }, {passive:false});

    // Enter key
    input.addEventListener("keydown", (e)=>{
      if(e.key==="Enter"){
        e.preventDefault();
        submit(e);
      }
    });

    // If user already had spins stored, show a small reminder
    if(state.spins.length){
      pushBubble(`Loaded ${state.spins.length} saved spins. Text: status or trend`, "in", ["loaded"]);
    }
  }

  // boot safely
  if(document.readyState==="loading") document.addEventListener("DOMContentLoaded", boot);
  else boot();

})();
</script>
</body>
</html>
